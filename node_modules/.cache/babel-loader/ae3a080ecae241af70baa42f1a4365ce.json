{"ast":null,"code":"import { focus, isFocusable } from \"@chakra-ui/utils\";\nimport { useRef } from \"react\";\nimport { useEventListener } from \"./use-event-listener\";\nimport { useUpdateEffect } from \"./use-update-effect\";\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\n\nexport function useFocusOnHide(popoverRef, options) {\n  var isFocusableRef = useRef(false);\n  var {\n    focusRef,\n    shouldFocus,\n    visible\n  } = options;\n  var autoFocus = shouldFocus && !visible;\n\n  var onPointerDown = event => {\n    if (!options.visible) return;\n    var target = event.target;\n    var prevent = isFocusable(target) && target !== focusRef.current && !popoverRef.current.contains(target);\n\n    if (prevent) {\n      isFocusableRef.current = true;\n    }\n  };\n\n  useEventListener(\"mousedown\", onPointerDown);\n  useEventListener(\"touchstart\", onPointerDown);\n  useUpdateEffect(() => {\n    return () => {\n      if (!visible) {\n        isFocusableRef.current = false;\n      }\n    };\n  }, [visible]);\n  useEventListener(\"transitionend\", () => {\n    if (!visible && focusRef.current && !isFocusableRef.current) {\n      focus(focusRef.current);\n    }\n  }, popoverRef.current);\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n\n  useUpdateEffect(() => {\n    if (!autoFocus || !popoverRef.current || isFocusableRef.current) return;\n\n    if (focusRef.current) {\n      focus(focusRef.current);\n    }\n  }, [autoFocus, focusRef, visible, popoverRef]);\n}","map":{"version":3,"sources":["../../src/use-focus-on-hide.ts"],"names":["isFocusableRef","useRef","visible","autoFocus","shouldFocus","onPointerDown","event","options","target","prevent","isFocusable","focusRef","popoverRef","useEventListener","useUpdateEffect","focus"],"mappings":"AAAA,SAAA,KAAA,EAAA,WAAA,QAAA,kBAAA;AACA,SAAA,MAAA,QAAA,OAAA;AACA,SAAA,gBAAA,QAAA,sBAAA;AACA,SAAA,eAAA,QAAA,qBAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,cAAA,CAAA,UAAA,EAAA,OAAA,EAGL;AACA,MAAMA,cAAc,GAAGC,MAAM,CAA7B,KAA6B,CAA7B;AACA,MAAM;AAAA,IAAA,QAAA;AAAA,IAAA,WAAA;AAAyBC,IAAAA;AAAzB,MAAN,OAAA;AAEA,MAAMC,SAAS,GAAGC,WAAW,IAAI,CAAjC,OAAA;;AAEA,MAAMC,aAAa,GAAIC,KAAD,IAAoC;AACxD,QAAI,CAACC,OAAO,CAAZ,OAAA,EAAsB;AACtB,QAAMC,MAAM,GAAGF,KAAK,CAApB,MAAA;AAEA,QAAMG,OAAO,GACXC,WAAW,CAAXA,MAAW,CAAXA,IACAF,MAAM,KAAKG,QAAQ,CADnBD,OAAAA,IAEA,CAAEE,UAAU,CAAX,OAACA,CAAD,QAACA,CAHJ,MAGIA,CAHJ;;AAKA,QAAA,OAAA,EAAa;AACXZ,MAAAA,cAAc,CAAdA,OAAAA,GAAAA,IAAAA;AACD;AAXH,GAAA;;AAcAa,EAAAA,gBAAgB,CAAA,WAAA,EAAhBA,aAAgB,CAAhBA;AACAA,EAAAA,gBAAgB,CAAA,YAAA,EAAhBA,aAAgB,CAAhBA;AAEAC,EAAAA,eAAe,CAAC,MAAM;AACpB,WAAO,MAAM;AACX,UAAI,CAAJ,OAAA,EAAc;AACZd,QAAAA,cAAc,CAAdA,OAAAA,GAAAA,KAAAA;AACD;AAHH,KAAA;AADa,GAAA,EAMZ,CANHc,OAMG,CANY,CAAfA;AAQAD,EAAAA,gBAAgB,CAAA,eAAA,EAEd,MAAM;AACJ,QAAI,CAAA,OAAA,IAAYF,QAAQ,CAApB,OAAA,IAAgC,CAACX,cAAc,CAAnD,OAAA,EAA6D;AAC3De,MAAAA,KAAK,CAACJ,QAAQ,CAAdI,OAAK,CAALA;AACD;AALW,GAAA,EAOdH,UAAU,CAPZC,OAAgB,CAAhBA;AAUA;AACF;AACA;AACA;;AACEC,EAAAA,eAAe,CAAC,MAAM;AACpB,QAAI,CAAA,SAAA,IAAc,CAACF,UAAU,CAAzB,OAAA,IAAqCZ,cAAc,CAAvD,OAAA,EAAiE;;AACjE,QAAIW,QAAQ,CAAZ,OAAA,EAAsB;AACpBI,MAAAA,KAAK,CAACJ,QAAQ,CAAdI,OAAK,CAALA;AACD;AAJY,GAAA,EAKZ,CAAA,SAAA,EAAA,QAAA,EAAA,OAAA,EALHD,UAKG,CALY,CAAfA;AAMD","sourcesContent":["import { focus, FocusableElement, isFocusable } from \"@chakra-ui/utils\"\nimport { RefObject, useRef } from \"react\"\nimport { useEventListener } from \"./use-event-listener\"\nimport { useUpdateEffect } from \"./use-update-effect\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  popoverRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const isFocusableRef = useRef(false)\n  const { focusRef, shouldFocus, visible } = options\n\n  const autoFocus = shouldFocus && !visible\n\n  const onPointerDown = (event: MouseEvent | TouchEvent) => {\n    if (!options.visible) return\n    const target = event.target as HTMLElement\n\n    const prevent =\n      isFocusable(target) &&\n      target !== focusRef.current &&\n      !(popoverRef.current as HTMLElement).contains(target)\n\n    if (prevent) {\n      isFocusableRef.current = true\n    }\n  }\n\n  useEventListener(\"mousedown\", onPointerDown)\n  useEventListener(\"touchstart\", onPointerDown)\n\n  useUpdateEffect(() => {\n    return () => {\n      if (!visible) {\n        isFocusableRef.current = false\n      }\n    }\n  }, [visible])\n\n  useEventListener(\n    \"transitionend\",\n    () => {\n      if (!visible && focusRef.current && !isFocusableRef.current) {\n        focus(focusRef.current)\n      }\n    },\n    popoverRef.current,\n  )\n\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n  useUpdateEffect(() => {\n    if (!autoFocus || !popoverRef.current || isFocusableRef.current) return\n    if (focusRef.current) {\n      focus(focusRef.current)\n    }\n  }, [autoFocus, focusRef, visible, popoverRef])\n}\n"]},"metadata":{},"sourceType":"module"}