{"ast":null,"code":"import _slicedToArray from \"/Users/tommccarthy/nsf/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId, useSafeLayoutEffect } from \"@chakra-ui/hooks\";\nimport { callAllHandlers, createContext, getValidChildren, isUndefined, mergeRefs, normalizeEventKey } from \"@chakra-ui/utils\";\nimport { cloneElement, useCallback, useEffect, useRef, useState } from \"react\";\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * It's returned object will be passed unto a Context Provider\n * so all child components can read from it.\n *\n * @see Docs https://chakra-ui.com/components/useTabs\n */\n\nexport function useTabs(props) {\n  var defaultIndex = props.defaultIndex,\n      onChange = props.onChange,\n      index = props.index,\n      isManual = props.isManual,\n      isLazy = props.isLazy,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"defaultIndex\", \"onChange\", \"index\", \"isManual\", \"isLazy\", \"orientation\"]);\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n\n\n  var _useState = useState(defaultIndex != null ? defaultIndex : 0),\n      _useState2 = _slicedToArray(_useState, 2),\n      focusedIndex = _useState2[0],\n      setFocusedIndex = _useState2[1];\n\n  var _useControllableState = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange: onChange,\n    shouldUpdate: function shouldUpdate(prevIndex, nextIndex) {\n      return prevIndex !== nextIndex;\n    },\n    propsMap: {\n      value: \"index\",\n      defaultValue: \"defaultIndex\"\n    }\n  }),\n      _useControllableState2 = _slicedToArray(_useControllableState, 2),\n      selectedIndex = _useControllableState2[0],\n      setSelectedIndex = _useControllableState2[1];\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n\n\n  useEffect(function () {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n\n  var enabledDomContext = useDescendants();\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n\n  var domContext = useDescendants();\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n\n  var id = useId(props.id, \"tabs\");\n  return {\n    id: id,\n    selectedIndex: selectedIndex,\n    focusedIndex: focusedIndex,\n    setSelectedIndex: setSelectedIndex,\n    setFocusedIndex: setFocusedIndex,\n    isManual: isManual,\n    isLazy: isLazy,\n    orientation: orientation,\n    enabledDomContext: enabledDomContext,\n    domContext: domContext,\n    htmlProps: htmlProps\n  };\n}\n\nvar _createContext = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n}),\n    _createContext2 = _slicedToArray(_createContext, 2),\n    TabsProvider = _createContext2[0],\n    useTabsContext = _createContext2[1];\n\nexport { TabsProvider };\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\n\nexport function useTabList(props) {\n  var _useTabsContext = useTabsContext(),\n      setFocusedIndex = _useTabsContext.setFocusedIndex,\n      focusedIndex = _useTabsContext.focusedIndex,\n      orientation = _useTabsContext.orientation,\n      enabledDomContext = _useTabsContext.enabledDomContext;\n\n  var count = enabledDomContext.descendants.length;\n  /**\n   * Function to update the selected tab index\n   */\n\n  var setIndex = useCallback(function (index) {\n    var tab = enabledDomContext.descendants[index];\n\n    if (tab == null ? void 0 : tab.element) {\n      tab.element.focus();\n      setFocusedIndex(index);\n    }\n  }, [enabledDomContext.descendants, setFocusedIndex]);\n  var onKeyDown = useCallback(function (event) {\n    var nextTab = function nextTab() {\n      return setIndex((focusedIndex + 1) % count);\n    };\n\n    var prevTab = function prevTab() {\n      return setIndex((focusedIndex - 1 + count) % count);\n    };\n\n    var firstTab = function firstTab() {\n      return setIndex(0);\n    };\n\n    var lastTab = function lastTab() {\n      return setIndex(count - 1);\n    };\n\n    var isHorizontal = orientation === \"horizontal\";\n    var isVertical = orientation === \"vertical\";\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: function ArrowRight() {\n        return isHorizontal && nextTab();\n      },\n      ArrowLeft: function ArrowLeft() {\n        return isHorizontal && prevTab();\n      },\n      ArrowDown: function ArrowDown() {\n        return isVertical && nextTab();\n      },\n      ArrowUp: function ArrowUp() {\n        return isVertical && prevTab();\n      },\n      Home: firstTab,\n      End: lastTab\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [count, focusedIndex, orientation, setIndex]);\n  return _extends({}, props, {\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  });\n}\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\n\nexport function useTab(props) {\n  var isDisabled = props.isDisabled,\n      isFocusable = props.isFocusable,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\"]);\n\n  var _useTabsContext2 = useTabsContext(),\n      setSelectedIndex = _useTabsContext2.setSelectedIndex,\n      isManual = _useTabsContext2.isManual,\n      id = _useTabsContext2.id,\n      setFocusedIndex = _useTabsContext2.setFocusedIndex,\n      enabledDomContext = _useTabsContext2.enabledDomContext,\n      domContext = _useTabsContext2.domContext,\n      selectedIndex = _useTabsContext2.selectedIndex;\n\n  var ref = useRef(null);\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns it's index.\n   *\n   * Tab is registered if it's enabled or focusable\n   */\n\n  var enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current\n  });\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n\n  var index = useDescendant({\n    context: domContext,\n    element: ref.current\n  });\n  var isSelected = index === selectedIndex;\n\n  var onClick = function onClick() {\n    setFocusedIndex(enabledIndex);\n    setSelectedIndex(index);\n  };\n\n  var onFocus = function onFocus() {\n    var isDisabledButFocusable = isDisabled && isFocusable;\n    var shouldSelect = !isManual && !isDisabledButFocusable;\n\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n\n  var clickable = useClickable(_extends({}, htmlProps, {\n    ref: mergeRefs(ref, props.ref),\n    isDisabled: isDisabled,\n    isFocusable: isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  }));\n  var type = \"button\";\n  return _extends({}, clickable, {\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type: type,\n    \"aria-selected\": isSelected ? true : undefined,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus)\n  });\n}\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of it's children with\n * all functionality included.\n */\n\nexport function useTabPanels(props) {\n  var context = useTabsContext();\n  var id = context.id,\n      selectedIndex = context.selectedIndex;\n  var validChildren = getValidChildren(props.children);\n  var children = validChildren.map(function (child, index) {\n    return /*#__PURE__*/cloneElement(child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index)\n    });\n  });\n  return _extends({}, props, {\n    children: children\n  });\n}\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\n\nexport function useTabPanel(props) {\n  var isSelected = props.isSelected,\n      id = props.id,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isSelected\", \"id\"]);\n\n  var _useTabsContext3 = useTabsContext(),\n      isLazy = _useTabsContext3.isLazy;\n\n  return _extends({}, htmlProps, {\n    children: !isLazy || isSelected ? props.children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id: id\n  });\n}\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\n\nexport function useTabIndicator() {\n  var context = useTabsContext();\n  var selectedIndex = context.selectedIndex,\n      orientation = context.orientation,\n      domContext = context.domContext;\n  var isHorizontal = orientation === \"horizontal\";\n  var isVertical = orientation === \"vertical\"; // Get the clientRect of the selected tab\n\n  var _useState3 = useState(function () {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return undefined;\n  }),\n      _useState4 = _slicedToArray(_useState3, 2),\n      rect = _useState4[0],\n      setRect = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      hasMeasured = _useState6[0],\n      setHasMeasured = _useState6[1]; // Update the selected tab rect when the selectedIndex changes\n\n\n  useSafeLayoutEffect(function () {\n    var _tab$element;\n\n    if (isUndefined(selectedIndex)) return undefined;\n    var tab = domContext.descendants[selectedIndex];\n    var tabRect = tab == null ? void 0 : (_tab$element = tab.element) == null ? void 0 : _tab$element.getBoundingClientRect(); // Horizontal Tab: Calculate width and left distance\n\n    if (isHorizontal && tabRect) {\n      var left = tabRect.left,\n          width = tabRect.width;\n      setRect({\n        left: left,\n        width: width\n      });\n    } // Vertical Tab: Calculate height and top distance\n\n\n    if (isVertical && tabRect) {\n      var top = tabRect.top,\n          height = tabRect.height;\n      setRect({\n        top: top,\n        height: height\n      });\n    } // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n\n\n    var frameId = requestAnimationFrame(function () {\n      setHasMeasured(true);\n    });\n    return function () {\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants]);\n  return _extends({\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\"\n  }, rect);\n}\n\nfunction makeTabId(id, index) {\n  return id + \"--tab-\" + index;\n}\n\nfunction makeTabPanelId(id, index) {\n  return id + \"--tabpanel-\" + index;\n}","map":{"version":3,"sources":["../../src/use-tabs.ts"],"names":["orientation","useState","defaultIndex","useControllableState","defaultValue","value","onChange","shouldUpdate","prevIndex","propsMap","useEffect","isUndefined","setFocusedIndex","enabledDomContext","useDescendants","domContext","id","useId","props","selectedIndex","focusedIndex","setSelectedIndex","isManual","isLazy","htmlProps","createContext","name","errorMessage","useTabsContext","count","setIndex","useCallback","index","tab","onKeyDown","event","nextTab","prevTab","firstTab","lastTab","isHorizontal","isVertical","eventKey","normalizeEventKey","keyMap","ArrowRight","ArrowLeft","ArrowDown","ArrowUp","Home","End","action","role","callAllHandlers","isFocusable","ref","useRef","enabledIndex","useDescendant","disabled","Boolean","focusable","context","element","current","isSelected","onClick","onFocus","isDisabledButFocusable","isDisabled","shouldSelect","clickable","useClickable","mergeRefs","type","makeTabId","tabIndex","makeTabPanelId","validChildren","getValidChildren","children","cloneElement","hidden","left","width","top","height","useSafeLayoutEffect","tabRect","setRect","frameId","requestAnimationFrame","setHasMeasured","cancelAnimationFrame","position","transition","hasMeasured"],"mappings":"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","sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  callAllHandlers,\n  createContext,\n  Dict,\n  EventKeyMap,\n  getValidChildren,\n  isUndefined,\n  mergeRefs,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport {\n  ButtonHTMLAttributes,\n  cloneElement,\n  CSSProperties,\n  KeyboardEventHandler,\n  ReactElement,\n  ReactNode,\n  Ref,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance 🚀:\n   * If `true`, the TabPanel rendering will be deferred\n   * until it is open.\n   */\n  isLazy?: boolean\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * It's returned object will be passed unto a Context Provider\n * so all child components can read from it.\n *\n * @see Docs https://chakra-ui.com/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    orientation = \"horizontal\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n    shouldUpdate: (prevIndex, nextIndex) => prevIndex !== nextIndex,\n    propsMap: {\n      value: \"index\",\n      defaultValue: \"defaultIndex\",\n    },\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n  const enabledDomContext = useDescendants()\n\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n  const domContext = useDescendants()\n\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    orientation,\n    enabledDomContext,\n    domContext,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<ReturnType<typeof useTabs>, \"htmlProps\">\n\nconst [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport { TabsProvider }\n\ntype Child = ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: ReactNode\n  onKeyDown?: KeyboardEventHandler\n  ref?: Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    orientation,\n    enabledDomContext,\n  } = useTabsContext()\n\n  const count = enabledDomContext.descendants.length\n\n  /**\n   * Function to update the selected tab index\n   */\n  const setIndex = useCallback(\n    (index: number) => {\n      const tab = enabledDomContext.descendants[index]\n      if (tab?.element) {\n        tab.element.focus()\n        setFocusedIndex(index)\n      }\n    },\n    [enabledDomContext.descendants, setFocusedIndex],\n  )\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => setIndex((focusedIndex + 1) % count)\n      const prevTab = () => setIndex((focusedIndex - 1 + count) % count)\n      const firstTab = () => setIndex(0)\n      const lastTab = () => setIndex(count - 1)\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => isHorizontal && nextTab(),\n        ArrowLeft: () => isHorizontal && prevTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [count, focusedIndex, orientation, setIndex],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(\n  props: P,\n): ButtonHTMLAttributes<any> {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    enabledDomContext,\n    domContext,\n    selectedIndex,\n  } = useTabsContext()\n\n  const ref = useRef<HTMLElement>(null)\n\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns it's index.\n   *\n   * Tab is registered if it's enabled or focusable\n   */\n  const enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current,\n  })\n\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n  const index = useDescendant({\n    context: domContext,\n    element: ref.current,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setFocusedIndex(enabledIndex)\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickable = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(ref, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickable,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected ? true : undefined,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of it's children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, ...htmlProps } = props\n  const { isLazy } = useTabsContext()\n\n  return {\n    ...htmlProps,\n    children: !isLazy || isSelected ? props.children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): CSSProperties {\n  const context = useTabsContext()\n\n  const { selectedIndex, orientation, domContext } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = domContext.descendants[selectedIndex]\n    const tabRect = tab?.element?.getBoundingClientRect()\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal && tabRect) {\n      const { left, width } = tabRect\n      setRect({ left, width })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical && tabRect) {\n      const { top, height } = tabRect\n      setRect({ top, height })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const frameId = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (frameId) {\n        cancelAnimationFrame(frameId)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants])\n\n  return {\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module"}