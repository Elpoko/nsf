function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useClickable } from "@chakra-ui/clickable";
import { useDescendant, useDescendants } from "@chakra-ui/descendant";
import { useControllableState, useDisclosure, useEventListener, useFocusOnHide, useId, useIds, useOutsideClick, useShortcut, useUpdateEffect } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { addItem, callAllHandlers, createContext, dataAttr, focus, getNextIndex, getNextItemFromSearch, getPrevIndex, getValidChildren, isArray, isString, mergeRefs, mergeWith, normalizeEventKey, removeItem } from "@chakra-ui/utils";
import { cloneElement, useCallback, useRef, useState } from "react";
var [MenuProvider, useMenuContext] = createContext({
  strict: false,
  name: "MenuContext"
});
export { MenuProvider, useMenuContext };

/**
 * React Hook to manage a menu
 *
 * It provides the logic and will be used with react context
 * to propagate it's return value to all children
 */
export function useMenu(props) {
  var {
    id,
    closeOnSelect = true,
    closeOnBlur = true,
    autoSelect = true,
    placement: placementProp = "bottom-start",
    gutter,
    fixed = true,
    preventOverflow,
    modifiers,
    isLazy
  } = props;
  var {
    isOpen,
    onOpen,
    onClose,
    onToggle
  } = useDisclosure(props);
  /**
   * Prepare the reference to the menu and disclosure
   */

  var menuRef = useRef(null);
  var buttonRef = useRef(null);
  useOutsideClick({
    ref: menuRef,
    handler: event => {
      var _buttonRef$current;

      if (isOpen && closeOnBlur && !((_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.contains(event.target))) {
        onClose();
      }
    }
  });
  /**
   * Add some popper.js for dynamic positioning
   */

  var popper = usePopper({
    placement: placementProp,
    fixed,
    gutter,
    preventOverflow,
    modifiers
  });
  var [focusedIndex, setFocusedIndex] = useState(-1);
  /**
   * Context to register all menu item nodes
   */

  var domContext = useDescendants();
  /**
   * Focus the button when we close the menu
   */

  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen
  });
  /**
   * Generate unique ids for menu's list and button
   */

  var [buttonId, menuId] = useIds(id, "menu-button", "menu-list");
  var openAndFocusMenu = useCallback(() => {
    onOpen();
    if (menuRef.current) focus(menuRef.current);
  }, [onOpen, menuRef]);
  var openAndFocusFirstItem = useCallback(() => {
    onOpen();
    setFocusedIndex(0);
  }, [onOpen, setFocusedIndex]);
  var openAndFocusLastItem = useCallback(() => {
    onOpen();
    setFocusedIndex(domContext.descendants.length - 1);
  }, [onOpen, setFocusedIndex, domContext.descendants]);

  var refocus = () => {
    var _menuRef$current;

    var hasFocusWithin = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(document.activeElement);
    var shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus) return;
    requestAnimationFrame(() => {
      var _domContext$descendan;

      var el = (_domContext$descendan = domContext.descendants[focusedIndex]) == null ? void 0 : _domContext$descendan.element;
      el == null ? void 0 : el.focus({
        preventScroll: true
      });
    });
  };

  useEventListener("transitionend", refocus, menuRef.current);

  var onTransitionEnd = () => {
    var _menuRef$current2;

    /**
     * If we use CSS for transitioning this component, there would be no
     * need to dispatch a custom event. This is only useful for JS only
     * motion libraries like `framer-motion` to `react-spring`.
     *
     * They usually provide an `onRest` or `onAnimationComplete` callback we can
     * use to trigger the custom `transitionend` event.
     */
    (_menuRef$current2 = menuRef.current) == null ? void 0 : _menuRef$current2.dispatchEvent(new Event("transitionend"));
  };

  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd,
    domContext,
    popper,
    buttonId,
    menuId,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy
  };
}
export function useMenuList(props, ref) {
  if (ref === void 0) {
    ref = null;
  }

  var menu = useMenuContext();

  if (!menu) {
    throw new Error("useMenuContext: context is undefined. Seems you forgot the component within <Menu>");
  }

  var {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    popper,
    domContext: {
      descendants
    },
    isLazy
  } = menu;
  /**
   * Hook that creates a keydown event handler that listens
   * to printable keyboard character press
   */

  var onCharacterPress = useShortcut({
    preventDefault: event => event.key !== " "
  });
  var onKeyDown = useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Tab: event => {
        event.preventDefault();
      },
      Escape: onClose,
      ArrowDown: () => {
        var nextIndex = getNextIndex(focusedIndex, descendants.length);
        setFocusedIndex(nextIndex);
      },
      ArrowUp: () => {
        var prevIndex = getPrevIndex(focusedIndex, descendants.length);
        setFocusedIndex(prevIndex);
      }
    };
    var handler = keyMap[eventKey];

    if (handler) {
      event.preventDefault();
      handler(event);
      return;
    }

    var characterHandler = onCharacterPress(character => {
      /**
       * Typeahead: Based on current character pressed,
       * find the next item to be selected
       */
      var nextItem = getNextItemFromSearch(descendants, character, node => {
        var _node$element;

        return ((_node$element = node.element) == null ? void 0 : _node$element.textContent) || "";
      }, descendants[focusedIndex]);

      if (nextItem) {
        var index = descendants.indexOf(nextItem);
        setFocusedIndex(index);
      }
    });
    characterHandler(event);
  }, [descendants, focusedIndex, onCharacterPress, onClose, setFocusedIndex]);

  var menulistProps = _extends({}, props, {
    ref: mergeRefs(menuRef, ref),
    children: !isLazy || isOpen ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: _extends({}, props.style, {
      transformOrigin: popper.transformOrigin
    }),
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });

  return menulistProps;
}
export function useMenuPositioner(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    popper,
    isOpen
  } = useMenuContext();
  return mergeWith(popper.getPopperProps(props), {
    style: {
      visibility: isOpen ? "visible" : "hidden"
    }
  });
}
/**
 * React Hook to manage a menu button.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and it's return value
 * is passed as `context` to this hook.
 */

export function useMenuButton(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var menu = useMenuContext();
  var {
    isOpen,
    onClose,
    autoSelect,
    popper,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    openAndFocusMenu
  } = menu;
  var onClick = useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      var action = autoSelect ? openAndFocusFirstItem : openAndFocusMenu;
      action();
    }
  }, [autoSelect, isOpen, onClose, openAndFocusFirstItem, openAndFocusMenu]);
  var onKeyDown = useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    };
    var action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
    }
  }, [openAndFocusFirstItem, openAndFocusLastItem]);

  var buttonProps = _extends({}, props, {
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers(props.onClick, onClick),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });

  return popper.getReferenceProps(buttonProps, mergeRefs(menu.buttonRef, externalRef));
}
export function useMenuItem(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var {
    onClick: onClickProp,
    isDisabled,
    isFocusable
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable"]);

  var menu = useMenuContext();
  var {
    domContext,
    setFocusedIndex,
    focusedIndex,
    closeOnSelect,
    onClose,
    menuRef
  } = menu;
  var ref = useRef(null);
  var id = "menuitem-" + useId();
  /**
   * Register the menuitem's node into the domContext
   */

  var index = useDescendant({
    element: ref.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });
  var onMouseEnter = useCallback(() => {
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled]);
  var onMouseMove = useCallback(() => {
    if (document.activeElement !== ref.current) {
      onMouseEnter();
    }
  }, [onMouseEnter]);
  var onMouseLeave = useCallback(() => {
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled]);
  var onClick = useCallback(event => {
    onClickProp == null ? void 0 : onClickProp(event);
    /**
     * Close menu and parent menu's if `closeOnSelect` is set to `true`
     */

    if (closeOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, closeOnSelect]);
  var isFocused = index === focusedIndex;
  var trulyDisabled = isDisabled && !isFocusable;
  useUpdateEffect(() => {
    if (isFocused && !trulyDisabled && ref.current) {
      focus(ref.current);
    } else if (document.activeElement !== menuRef.current) {
      var _menuRef$current3;

      (_menuRef$current3 = menuRef.current) == null ? void 0 : _menuRef$current3.focus();
    }
  }, [isFocused, trulyDisabled, menuRef]);
  var tabbable = useClickable({
    onClick,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(ref, externalRef),
    isDisabled,
    isFocusable
  });
  return _extends({}, htmlProps, tabbable, {
    id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  });
}
export function useMenuOption(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var {
    onClick,
    isDisabled,
    isFocusable,
    type = "radio",
    isChecked
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable", "type", "isChecked"]);

  var hookProps = {
    isDisabled,
    isFocusable,
    onClick
  };
  var optionsProps = useMenuItem(hookProps, externalRef);
  return _extends({}, rest, optionsProps, {
    role: "menuitem" + type,
    "aria-checked": isChecked
  });
}
export function useMenuOptionGroup(props) {
  var {
    children,
    type = "radio",
    value: valueProp,
    defaultValue,
    onChange
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["children", "type", "value", "defaultValue", "onChange"]);

  var isRadio = type === "radio";
  var fallback = isRadio ? "" : [];
  var [value, setValue] = useControllableState({
    defaultValue: defaultValue != null ? defaultValue : fallback,
    value: valueProp,
    onChange
  });
  var handleChange = useCallback(selectedValue => {
    if (type === "radio" && isString(value)) {
      setValue(selectedValue);
    }

    if (type === "checkbox" && isArray(value)) {
      var nextValue = value.includes(selectedValue) ? removeItem(value, selectedValue) : addItem(value, selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  var validChildren = getValidChildren(children);
  var clones = validChildren.map(child => {
    /**
     * We've added an internal `id` to each `MenuItemOption`,
     * let's use that for type-checking.
     *
     * We can't rely on displayName or the element's type since
     * they can be changed by the user.
     */
    if (child.type.id !== "MenuItemOption") return child;

    var onClick = event => {
      handleChange(child.props.value);
      child.props.onClick == null ? void 0 : child.props.onClick(event);
    };

    var isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return /*#__PURE__*/cloneElement(child, {
      type,
      onClick,
      isChecked
    });
  });
  return _extends({}, htmlProps, {
    children: clones
  });
}
export function useMenuState() {
  var {
    isOpen,
    onClose
  } = useMenuContext();
  return {
    isOpen,
    onClose
  };
}
//# sourceMappingURL=use-menu.js.map