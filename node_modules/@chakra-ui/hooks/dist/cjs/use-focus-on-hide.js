"use strict";

exports.__esModule = true;
exports.useFocusOnHide = useFocusOnHide;

var _utils = require("@chakra-ui/utils");

var _react = require("react");

var _useEventListener = require("./use-event-listener");

var _useUpdateEffect = require("./use-update-effect");

/**
 * Popover hook to manage the focus when the popover closes or hides.
 *
 * We either want to return focus back to the popover trigger or
 * let focus proceed normally if user moved to another interactive
 * element in the viewport.
 */
function useFocusOnHide(popoverRef, options) {
  var isFocusableRef = (0, _react.useRef)(false);
  var focusRef = options.focusRef,
      shouldFocus = options.shouldFocus,
      visible = options.visible;
  var autoFocus = shouldFocus && !visible;

  var onPointerDown = function onPointerDown(event) {
    if (!options.visible) return;
    var target = event.target;
    var prevent = (0, _utils.isFocusable)(target) && target !== focusRef.current && !popoverRef.current.contains(target);

    if (prevent) {
      isFocusableRef.current = true;
    }
  };

  (0, _useEventListener.useEventListener)("mousedown", onPointerDown);
  (0, _useEventListener.useEventListener)("touchstart", onPointerDown);
  (0, _useUpdateEffect.useUpdateEffect)(function () {
    return function () {
      if (!visible) {
        isFocusableRef.current = false;
      }
    };
  }, [visible]);
  (0, _useEventListener.useEventListener)("transitionend", function () {
    if (!visible && focusRef.current && !isFocusableRef.current) {
      (0, _utils.focus)(focusRef.current);
    }
  }, popoverRef.current);
  /**
   * Using updateEffect here to allow effect to run only when
   * `options.visible` changes, not on mount
   */

  (0, _useUpdateEffect.useUpdateEffect)(function () {
    if (!autoFocus || !popoverRef.current || isFocusableRef.current) return;

    if (focusRef.current) {
      (0, _utils.focus)(focusRef.current);
    }
  }, [autoFocus, focusRef, visible, popoverRef]);
}
//# sourceMappingURL=use-focus-on-hide.js.map